1. JWT는 세션의 고질적인 문제를 해결하기 위해 사용된다.
    세션의 고질적인 문제란
        클라이언트가 로그인을 요청할 경우, 
            1. 클라이언트가 최초의 requeset를 한다.
            2. 요청을 받게 된 서버는 세션이라는 저장소에 세션 ID를 생성한다.(이때, 세션 ID가 가지고 있는 조그마한 저장소도 함께 생성)
                (다른 사용자의 요청이 들어오게 된다면 그 사용자의 세션 ID를 추가로 생성한다.)
            3. 서버가 클라이언트에게 response(응답)을 해줄 때, header에 세션 ID를 붙여서 응답하게 된다.
            4. 응답을 받게 된 클라이언트의 웹 브라우져에 세션 ID가 저장된다.
            5. 클라이언트가 로그인 요청을 하게 된다.
                (ID와 password를 날린다.)
            6. 데이터베이스에 클라이언트가 날린 ID와 password가 존재하는지 확인한다.
            7. 정보가 정상이라면 세션 ID 안에 생성된 조그마한 저장소 안에 user의 정보(데이터베이스에 존재)를 저장한다.
            8. 로그인이 성공하게 된다면 메인 페이지로 return.
            9. 클라이언트가 인증이 필요한 페이지(유저 정보 등)를 요청하게 된다면 서버는 세션이 존재하는지 확인한다.
            10. 세션에 정보가 존재한다면 서버는 데이터베이스에서 사용자 정보를 응답 받는다.
            11. 서버는 클라이언트에게 정보를 응답한다.
                - 반복

        이러한 세션의 단점은 클라이언트의 수가 300명이고, 서버가 수용할 수 있는 공간이 100이라면 3개의 서버를 사용해야한다.
        즉, 하나의 서버에 클라이언트가 몰릴 경우, 다른 서버로 요청을 받는 것이다.(로드 벨런싱)
            이와 같이 동작할 경우, 첫 번째고 요청을 했을 때, 1번 서버에서 세션 ID를 받게 된 상황에서 1번 서버가 혼잡해지면 2번 서버로 요청을 넘겨주게 된다.
            하지만, 2번 서버에는 세션의 정보가 없기 때문에 다시 세션을 생성하게 되는 문제가 발생한다.

            이 문제를 해결하기 위한 방법은 한 서버에만 연결, 세션 복사 등이 있으며 그 중에서는 세션에 정보를 저장하는 것이 아닌 하나의 데이터베이스에 저장하여 사용하는 것이다.

            하지만, 데이터베이스에 저장된 정보를 이용하게 된다면 하드디스크에서 정보를 찾아야하기 때문에 속도가 느려진다.
                (세션에 저장하여 사용할 경우 메모리(RAM)를 사용하는 것으로 속도가 빠르다.)

            때문에 데이터베이스에 저장하는 것이 아닌, 메모리 공유 서버(RAM만 존재(하드디스크 존재하지 않음))를 사용한다.

2. OSI 계층(물, 데, 네, 트, 세, 프, 응)
    응용 계층에서 시작해서 프리젠테이션, 세션, 트랜스포트, 네트워크, 데이터 링크, 물리 계층을 통과하여 전송되고 다시 물리 계층부터 응용 계층으로 올라가 통신을 완료한다.
    (응용 : 프로그램, 데이터 /  프리젠테이션 : 암호화, 암축 / 세션 : 인증 체크 /  트랜스포트 : TCP, UDP 통신 / 네트워크 : IP / 데이터 링크 : 네트워크 계층 다음 구역을 찾아간다. / 물리 : 광케이블)
        (TCP 통신 - A가 B에게 통신하게 될 경우, 통신을 받은 B는 ack를 넘겨준다. 만약, ack가 넘어오지 않는다면 A는 이전과 같은 데이터로 B에게 통신을 시도한다.(신뢰성))
        (UDP 통신 - A가 B에게 통신하는데 B에게서 ack를 받지 않아도 계속해서 다음 정보를 통신한다.(신뢰성 X))

3. CIA(기밀성, 무결성(변경의 유무), 가용성(원하는 정보에 접근))
    RSA(암호화)
        public key  : 공개키    -> 대칭키는 공개키 기반이다.
        private key : 개인키

        A가 B에게 문서를 전달할 때, A는 B의 공개키로 문서를 암호화한다.
        문서를 받게 된 B는 자신이 가지고 있는 개인키로 문서를 풀 수 있다.   (공개키와 개인키는 하나의 쌍으로 존재하고, 개인키가 있어야 공개키로 암호화한 문서를 읽을 수 있다.)

        반대로 A가 문서를 보낼 때, A의 개인키로 암호화하고, B는 A의 공개키로 문서를 열어볼 수 있다.
        이와 같은 경우는 A의 공개키로 문서를 연 순간, A가 문서를 작성했다는 사실이 확정된다.(A만 A의 개인키로 암호화할 수 있다.)    (전자 서명에 사용)

    즉, 보안을 위해서는 A가 B에게 문서를 보낼 경우,
        먼저, B의 공개키로 암호화를 진행한 뒤, A의 개인키로 암호화를 한 번 더 진행한다.