1. JWT는 세션의 고질적인 문제를 해결하기 위해 사용된다.
    세션의 고질적인 문제란
        클라이언트가 로그인을 요청할 경우, 
            1. 클라이언트가 최초의 requeset를 한다.
            2. 요청을 받게 된 서버는 세션이라는 저장소에 세션 ID를 생성한다.(이때, 세션 ID가 가지고 있는 조그마한 저장소도 함께 생성)
                (다른 사용자의 요청이 들어오게 된다면 그 사용자의 세션 ID를 추가로 생성한다.)
            3. 서버가 클라이언트에게 response(응답)을 해줄 때, header에 세션 ID를 붙여서 응답하게 된다.
            4. 응답을 받게 된 클라이언트의 웹 브라우져에 세션 ID가 저장된다.
            5. 클라이언트가 로그인 요청을 하게 된다.
                (ID와 password를 날린다.)
            6. 데이터베이스에 클라이언트가 날린 ID와 password가 존재하는지 확인한다.
            7. 정보가 정상이라면 세션 ID 안에 생성된 조그마한 저장소 안에 user의 정보(데이터베이스에 존재)를 저장한다.
            8. 로그인이 성공하게 된다면 메인 페이지로 return.
            9. 클라이언트가 인증이 필요한 페이지(유저 정보 등)를 요청하게 된다면 서버는 세션이 존재하는지 확인한다.
            10. 세션에 정보가 존재한다면 서버는 데이터베이스에서 사용자 정보를 응답 받는다.
            11. 서버는 클라이언트에게 정보를 응답한다.
                - 반복

        이러한 세션의 단점은 클라이언트의 수가 300명이고, 서버가 수용할 수 있는 공간이 100이라면 3개의 서버를 사용해야한다.
        즉, 하나의 서버에 클라이언트가 몰릴 경우, 다른 서버로 요청을 받는 것이다.(로드 벨런싱)
            이와 같이 동작할 경우, 첫 번째고 요청을 했을 때, 1번 서버에서 세션 ID를 받게 된 상황에서 1번 서버가 혼잡해지면 2번 서버로 요청을 넘겨주게 된다.
            하지만, 2번 서버에는 세션의 정보가 없기 때문에 다시 세션을 생성하게 되는 문제가 발생한다.

            이 문제를 해결하기 위한 방법은 한 서버에만 연결, 세션 복사 등이 있으며 그 중에서는 세션에 정보를 저장하는 것이 아닌 하나의 데이터베이스에 저장하여 사용하는 것이다.

            하지만, 데이터베이스에 저장된 정보를 이용하게 된다면 하드디스크에서 정보를 찾아야하기 때문에 속도가 느려진다.
                (세션에 저장하여 사용할 경우 메모리(RAM)를 사용하는 것으로 속도가 빠르다.)

            때문에 데이터베이스에 저장하는 것이 아닌, 메모리 공유 서버(RAM만 존재(하드디스크 존재하지 않음))를 사용한다.

2. OSI 계층(물, 데, 네, 트, 세, 프, 응)
    응용 계층에서 시작해서 프리젠테이션, 세션, 트랜스포트, 네트워크, 데이터 링크, 물리 계층을 통과하여 전송되고 다시 물리 계층부터 응용 계층으로 올라가 통신을 완료한다.
    (응용 : 프로그램, 데이터 /  프리젠테이션 : 암호화, 암축 / 세션 : 인증 체크 /  트랜스포트 : TCP, UDP 통신 / 네트워크 : IP / 데이터 링크 : 네트워크 계층 다음 구역을 찾아간다. / 물리 : 광케이블)
        (TCP 통신 - A가 B에게 통신하게 될 경우, 통신을 받은 B는 ack를 넘겨준다. 만약, ack가 넘어오지 않는다면 A는 이전과 같은 데이터로 B에게 통신을 시도한다.(신뢰성))
        (UDP 통신 - A가 B에게 통신하는데 B에게서 ack를 받지 않아도 계속해서 다음 정보를 통신한다.(신뢰성 X))

3. CIA(기밀성, 무결성(변경의 유무), 가용성(원하는 정보에 접근))
    RSA(암호화)
        public key  : 공개키    -> 대칭키는 공개키 기반이다.
        private key : 개인키

        A가 B에게 문서를 전달할 때, A는 B의 공개키로 문서를 암호화한다.
        문서를 받게 된 B는 자신이 가지고 있는 개인키로 문서를 풀 수 있다.   (공개키와 개인키는 하나의 쌍으로 존재하고, 개인키가 있어야 공개키로 암호화한 문서를 읽을 수 있다.)

        반대로 A가 문서를 보낼 때, A의 개인키로 암호화하고, B는 A의 공개키로 문서를 열어볼 수 있다.
        이와 같은 경우는 A의 공개키로 문서를 연 순간, A가 문서를 작성했다는 사실이 확정된다.(A만 A의 개인키로 암호화할 수 있다.)    (전자 서명에 사용)

    즉, 보안을 위해서는 A가 B에게 문서를 보낼 경우,
        먼저, B의 공개키로 암호화를 진행한 뒤, A의 개인키로 암호화를 한 번 더 진행한다.

4. JWT란?
    : JWt(Json Web Token)는 당사자간의 정보를 Json 객체로 안전하게 전송하기 위한 컴팩트하고 독립적인 방식을 정의하는 개방 표준(RFC 7519)이다.
        이는 디지털 서명이 되어있으므로 신뢰할 수 있다.(HMAC 또는 RSA 사용)

    JWT는 Header(x 부분), Payload(y 부분), Signature(z 부분)으로 구성된다.
        - xxxxx.yyyyy.zzzzz

        - Header : Header는 일반적으로 토큰 유형과 사용중인 서명 알고리즘의 두 부분으로 구성된다.
            {
                "alg": "HS256",
                "typ": "JWT"
            }

        - Payload : 엔터티(일반적으로 사용자) 및 추가 데이터에 대한 설명으로 클레임에는 등록된 클레임, 공개 클레임 및 비공개 클레임 의 세 가지 유형이 있다.

            Registered claims(등록된 클레임)    : 필수는 아니지만 유용하고 상호 운용 가능한 클레임을 제공하기 위해 권장되는 미리 정의된 클레임 집합.
                                                    그들 중 일부는 iss (발급자), exp (만료 시간), sub (주제), aud (대상) 및 기타 이다.
            Public claims(공개 클레임)          : JWT를 사용하는 사람들이 마음대로 정의할 수 있음.
                                                    그러나 충돌을 방지하려면 IANA JSON 웹 토큰 레지스트리 에 정의하거나 충돌 방지 네임스페이스를 포함하는 URI로 정의해야 한다.
            Private claims(비공개 클레임)       : 사용에 동의한 당사자 간에 정보를 공유하기 위해 생성된 사용자 정의 클레임이며 등록 또는 공개 클레임이 아니다.

            {
                "sub": "1234567890",
                "name": "John Doe",
                "admin": true
            }

        - Signature : 서명 부분을 생성하려면 인코딩된 헤더, 인코딩된 페이로드, 비밀, 헤더에 지정된 알고리즘을 가져와서 서명해야한다.
            예를 들어 HMAC SHA256 알고리즘을 사용하려는 경우 서명은 다음과 같은 방식으로 생성됩니다.

            HMACSHA256(
                base64UrlEncode(header) + "." +
                base64UrlEncode(payload),
                secret)

            서명은 메시지가 도중에 변경되지 않았는지 확인하는 데 사용되며 개인 키로 서명된 토큰의 경우 JWT 발신자가 누구인지 확인할 수도 있다.